#!/usr/bin/env bash

# _    _          _ ____        _
#| | _(_)_ __ ___(_) ___|  __ _| | ___   _ _ __ __ _
#| |/ / | '__/ _ \ \___ \ / _` | |/ / | | | '__/ _` |
#|   <| | | |  __/ |___) | (_| |   <| |_| | | | (_| |
#|_|\_\_|_|  \___|_|____/ \__,_|_|\_\\__,_|_|  \__,_|
#
# Main executable script for KireiSakura-Kit




#_____________________________________FUNCTIONS_____________________________________________

# set -x

[[ $- != *i* ]] && shopt -s expand_aliases

# Log function
logf() {
  local message="$1"
  local timestamp
  local formatted_message

  timestamp="[$(date '+%Y.%m.%d %H:%M:%S')] "

  # Replace '\n' with actual newlines
  formatted_message=$(echo -e "$message")

  while IFS= read -r line; do
    printf "%s %s\n" "$timestamp" "$line" >>"$log_file"
  done <<<"$formatted_message"
}

output() {
  local log_level="$1"
  local log_message="$2"
  local prsd_message=""
  local logger_loaded=false
  local formatted_message=""

  # Only try to load the logger module once
  if [[ "$logger_loaded" == "false" ]]; then
    if source "$lib_dir/logging.sh" && type __logger &>/dev/null; then
      logger_loaded=true
      logf "Logger module loaded successfully."
    else
      logger_loaded=failed
    fi
  fi

  if [[ "$logger_loaded" == "true" ]]; then

    formatted_message="$(__logger -l "$log_level" -f "$log_file" "$log_message")"

    printf 'echo -e "%s"\n' "$formatted_message"
  else

    if [[ "$logger_loaded" == "failed" ]]; then
      echo -e "${RED}Errors: Failed to load logger module.${NC}" >&2
      logger_loaded=error_shown
    fi
  
    case "$log_level" in
      success) symbol="✓"; color="$GREEN"; bold_color="$BOLD_GREEN" ;;
      warn)    symbol="⚠"; color="$YELLOW"; bold_color="$BOLD_YELLOW" ;;
      error)   symbol="✗"; color="$RED"; bold_color="$BOLD_RED" ;;
      info)    symbol="ℹ"; color="$YELLOW"; bold_color="$BOLD_YELLOW" ;;
      *)       symbol="➤"; color="$NC"; bold_color="$BOLD_NC" ;;
    esac

    formatted_message="${bold_color}${symbol}${NC}${color} ${log_message}${NC}"
    
    printf 'echo -e "%s"\n' "$formatted_message"
    
    logf "[$log_level] $log_message"
  fi
}

alias output.info='output info'
alias output.error='output error'
alias output.warn='output warn'
alias output.success='output success'
alias output.nyi='output error "NOT YET IMPLEMENTED!"'

clearx() {
	cat <<-'CLEARX'
	echo -e "\n\n\n\n\n"
	printf '\n%.0s' $(seq 1 "$(tput lines)"); tput cup 0 0
	CLEARX
}

# For no arguments
show_man() {
  local opt=${1:-" "}

  if [ "$opt" != " " ]; then
    echo -e "\n  ${RED}Unknown flag: '$opt' ${NC}\n"
  else
    echo -e "\n  ${RED}No flag was given.${NC}\n"
  fi

  echo -e "  Use '${LAVENDER}kireisakura -h${NC}' for help."

  exit 1
}

# Help message
show_help() {

  echo -e "\n  Usage: ${LAVENDER}kireisakura {OPTIONS}${NC}"
  echo -e "  Usage: ${LAVENDER}eval '\$(kireisakura --init {OPTIONS})'${NC}\n"

  echo "  Options:"
  echo "      -i,  --init            Set up the KireiSakura-Kit."
  echo "      -d,  --dir <path>      Set up a custom installation. Must use with -i."
  echo "      -h,  --help            Show this help message and exit."
  echo "      -v,  --version         Show version and exit."
  echo "      -u,  --update          Update to newest version if available."
  echo "      -ul, --update-url      Upstream url. Direct link to '.version'."
  echo "      -t,  --test            Run the test script to verify the setup."

  exit 0
}

get_version() {
  local url version prg="curl"

  case "$1" in
    -u | --upstream)
      version="$(curl -s --connect-timeout 3 "$upstream_ver_url" || echo "N/A" )"
      ;;
    -l | --local)
      version="$(cat "$kit_ver_url" || echo "N/A")"
      ;;
    -* | --*)
      echo "Usage: get_version [-u|--upstream] [-l|--local]"
      return 1
      ;;
    *)
      version="$(cat "$kit_ver_url" || echo "N/A")"
      ;;
  esac

  echo "$version"

  if [[ -z "$version" || "$version" == "N/A" ]]; then
    return 1
  else
    return 0
  fi
}

show_version() {
  local upstream=false
  local version
  
  if [[ "$1" == "-u" || "$1" == "--upstream-version" ]]; then
    version="$(get_version -u)"
  else
    version="$(get_version)"
  fi

  if [[ "$version" == "N/A" ]]; then
    echo -e "  ${RED}Error: Unable to retrieve version.${NC}\n"
    exit 1
  else
    echo -e "\n  KireiSakura-Kit ${LAVENDER}v${version}${NC}\n"
    exit 0
  fi
}

compare_num() {
  local ver1
  local ver2
  local v1_part
  local v2_part

  if [[ $BASH_VERSION ]]; then
    IFS='.' read -r -a ver1 <<<"$1"
    IFS='.' read -r -a ver2 <<<"$2"
  else
    IFS='.' read -rA ver1 <<<"$1"
    IFS='.' read -rA ver2 <<<"$2"
  fi

  for i in {0..2}; do

    v1_part=${ver1[i]:-0}
    v2_part=${ver2[i]:-0}

    if ((v1_part > v2_part)); then
      echo 1
      return
    elif ((v1_part < v2_part)); then
      echo 2
      return
    fi
  done

  echo 0
  return 0
}

update_kit() {
  local result
  local upstream_version
  local local_version
  
  # Get local version
  local_version="$(get_version || echo "N/A")"
  
  # Get upstream version with -u flag
  upstream_version="$(get_version -u || echo "N/A")"

  if [[ "$upstream_version" == "N/A" ]]; then
    echo -e " ${RED}Couldn't resolve upstream version. Please check your connection or the URL.${NC}"
    return 1
  fi
  
  if [[ "$local_version" == "N/A" ]]; then
    echo -e " ${RED}Couldn't resolve local version. Please check your installation.${NC}"
    return 1
  fi

  # Compare versions
  result=$(compare_num "$local_version" "$upstream_version")

  if [ "$result" -eq 2 ]; then
    echo -e "\n  ${YELLOW}New update available:${NC} ${LAVENDER}v${local_version} -> v${upstream_version} ${NC}"
    echo -e " ${YELLOW}Updating....${NC}"

    curl -L "$kit_installer_url" | bash -s || {
      echo -e " ${RED}Update failed. Please try again manually.${NC}"
      return 1
    }

  elif [[ $result -eq 0 ]]; then
    echo -e "\n  ${GREEN}No new update available.${NC}"
    echo -e "  KireiSakura-Kit ${LAVENDER}v${local_version}${NC}"

  else
    echo -e "! Local version is greater than Official release?"
    echo -e "    Local:    ${LAVENDER}v${local_version}${NC}"
    echo -e "    Upstream: ${LAVENDER}v${upstream_version}${NC}"
    echo -e " Are you a dev?"
    echo -e " If not, please reinstall."
  fi
}

run_tester() {
  echo -e "\n${LAVENDER}================= KireiSakura Kit Test Utility ==================${NC}\n"

  if bash "$lib_dir/_test.sh"; then
    echo -e "\n\n${GREEN}================ TEST SUCCESSFULLY COMPLETED ==================${NC}\n"
    exit 0
  else
    echo -e "\n\n${RED}================== TEST FAILED ==================${NC}\n"
    exit 1
  fi
}

# Setup process
# TODO: make the header logo middle of the screen
init_kit() {
  
  logf "\n\n" >>"$log_file"
  logf "====================== NEW SESSION =======================\n"
  logf "Started in: $(pwd)/"
  logf "Initialization started."

  # 1st heading
  clearx
  cat <<-INIT_HEADER
	command -v figlet >/dev/null 2>&1 && figlet "$project_name" || cat "\$K_ASSETS_DIR/header.txt"
	INIT_HEADER

  output.warn "INIT: Starting initialization process...\\\n\\\n"

  # Config file status
  [[ "$config_file" == "NULL" ]] ||  output.success "Loaded Config file."
  sleep 1

  # Check kit directory
  if [ "$is_cstm_kit_dir" = true ]; then
    output.info "Custom Kit directory given."
    output.warn "Checking it..."
    
    if [ ! -d "$kit_dir" ]; then
      output.error "Error: Custom Kit directory does not exist. Please check given directory path."
      output.error "Exiting..."
      exit 1
    else
      output.success "Custom Kit directory exists."
    fi
  else
    output.warn "Using default Kit installation."
    output.warn "Validating..."
    
    if [ ! -d "$kit_dir" ]; then
      output.error "Error: Default installation is missing. Please re-install the kit."
      output.error "Exiting..."
      exit 1
    else
      output.success "Validated default installation."
      echo
    fi
  fi

  # Check if init file exists
  if [ ! -f "$init_file" ]; then
    output.error "Error: Init file is missing in Kit. Please check installation or re-install."
    printf "echo -e 'Exiting.....' \n"
    exit 1
  fi

  # Output super variables organized by groups
  cat <<-SUPER_VARS

	# Super Variables

  export K_LOADED_MODULES=()

	export K_KIT_NAME="$kit_name"
	export K_KIT_OWNER="$kit_owner"
	export K_KIT_SITE="$kit_site"
	export K_KIT_REPO="$kit_repo"
	export K_KIT_BRANCH="$kit_repo_branch"

	export K_KIT_DIR="$kit_dir"
	export K_LIB_DIR="$lib_dir"
	export K_INIT_FILE="$init_file"
	export K_PACKAGE_DIR="$package_dir"
	export K_ASSETS_DIR="$assets_dir"

	export K_KIT_INSTALLER_URL="$kit_installer_url"
	export K_KIT_VER_URL="$kit_ver_url"
	export K_KIT_UPSTREAM_VER_URL="$upstream_ver_url"

	export K_PRJ_NAME="$project_name"
	export K_PRJ_OWNER="$project_owner"
	export K_PRJ_URL="$project_url"
	export K_PRJ_REPO="$project_repo"
	export K_PRJ_CONFIG="$project_config_file"

	export K_DEBUG_MODE=$debug_mode

	export K_CACHE_DIR="$cache_dir"
	export K_LOG_FILE="$log_file"

	# Get version information
	local_ver="$(get_version)" 
	upstream_ver="$(get_version -u)"
	
	export K_KIT_VERSION="${local_ver:-N/A}"
	export K_KIT_UPSTREAM_VERSION="${upstream_ver:-N/A}"

	SUPER_VARS


  # Final initialization steps
  printf "\nsleep 1\n"
  logf "Loading init file....."
  output.warn "Loading init file..."

  # Source init file and verify
  cat <<-INIT_FINAL
	source "\$K_INIT_FILE"
	log.success 'Init file loaded successfully.'
	
	sleep 1
	log.warn "Checking cache directory..."
  
	__is_dir_exists "\${K_CACHE_DIR}" -n
	log.success "Cache directory verified."
	
	echo
	log "KireiSakura-Kit v$(get_version)"
	
	sleep 1
	echo " \\n "
	
	log.success "Initialization completed successfully." INIT

	INIT_FINAL

  logf "Initialization complete."
  exit 0
}


#_________________________________ Default Configuration Values __________________________________________

# Super variables
kit_name="KireiSakura-Kit"                 # K_KIT_NAME
kit_owner="soymadip"                       # K_KIT_OWNER
kit_site="https://kireisakura.soymadip.me" # K_KIT_SITE
kit_repo="${kit_owner}/${kit_name}"        # K_KIT_REPO
kit_repo_branch="main"                     # K_KIT_BRANCH

kit_dir="$HOME/.local/share/${kit_name}"   # K_KIT_DIR
lib_dir="$kit_dir/lib"                     # K_LIB_DIR
init_file="$lib_dir/__init__.sh"           # K_INIT_FILE
package_dir="$kit_dir/packages"            # K_PACKAGE_DIR
assets_dir="$kit_dir/Assets"               # K_ASSETS_DIR

kit_installer_url="${kit_site}/install"    # K_KIT_INSTALLER_URL
kit_ver_url="$kit_dir/.version"            # K_KIT_VER_URL
upstream_ver_url="$kit_site/version"       # K_KIT_UPSTREAM_VER_URL

project_name="$kit_name"                   # K_PRJ_NAME
project_owner="$kit_owner"                 # K_PRJ_OWNER
project_url="$kit_site"                    # K_PRJ_URL
project_repo="$kit_repo"                   # K_PRJ_REPO
project_config_file="config.yml"           # K_PRJ_CONFIG

debug_mode=false                           # K_DEBUG_MODE

cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/${project_name}" # K_CACHE_DIR
log_file="${cache_dir}/${project_name}.log"                 # K_LOG_FILE


# ____________________________________ Main _________________________________________________

# source colors
eval "$("$(dirname "$0")/../lib/_colors.sh")"

# Parse option
while [[ "$#" -ge 0 ]]; do

  case "$1" in
  -h | --help)
    show_help
    ;;
  -u | --update)
    update_kit
    ;;
  -v | --version)
    show_version
    ;;
  -uv | --upstream-version)
    show_version -u
    ;;
  -t | --test)
    run_tester
    ;;
  -i | --init)
    mkdir -p "$cache_dir"
    init_kit
    ;;
  *)
    show_man "$1"
    ;;
  esac
  shift
done
